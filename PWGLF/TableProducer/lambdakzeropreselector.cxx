// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
//
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//  Lambdakzero builder task
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//
//  This task loops over a set of V0 indices and
//  creates the corresponding analysis tables that contain
//  the typical information required for analysis.
//
//  PERFORMANCE WARNING: this task includes several track
//  propagation calls that are intrinsically heavy. Please
//  also be cautious when adjusting selections: these can
//  increase / decrease CPU consumption quite significantly.
//
//  IDEAL USAGE: if you are interested in taking V0s and
//  cascades and propagating TrackParCovs based on these,
//  please do not re-propagate the daughters. Instead,
//  the tables generated by this builder task can be used
//  to instantiate a TrackPar object (default operation)
//  or even a TrackParCov object (for which you will
//  need to enable the option of producing the V0Cov and
//  CascCov tables too).
//
//    Comments, questions, complaints, suggestions?
//    Please write to:
//    david.dobrigkeit.chinellato@cern.ch
//

#include <cmath>
#include <array>
#include <cstdlib>
#include <map>
#include <iterator>
#include <utility>

#include "Framework/runDataProcessing.h"
#include "Framework/RunningWorkflowInfo.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Framework/ASoAHelpers.h"
#include "DCAFitter/DCAFitterN.h"
#include "ReconstructionDataFormats/Track.h"
#include "Common/Core/RecoDecay.h"
#include "Common/Core/trackUtilities.h"
#include "PWGLF/DataModel/LFStrangenessTables.h"
#include "PWGLF/DataModel/LFParticleIdentification.h"
#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"
#include "DetectorsBase/Propagator.h"
#include "DetectorsBase/GeometryManager.h"
#include "DataFormatsParameters/GRPObject.h"
#include "DataFormatsParameters/GRPMagField.h"
#include "CCDB/BasicCCDBManager.h"
#include "DataFormatsCalibration/MeanVertexObject.h"
#include "TableHelper.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
struct lambdakzeroPreselector {
  Produces<aod::V0Presels> v0presels; // V0 preselections
  uint8_t selectionFlag;

  // for bookkeeping
  HistogramRegistry histos{"Histos", {}, OutputObjHandlingPolicy::AnalysisObject};

  Configurable<float> dauEtaMin{"v0detaMin", -0.8, "minimum V0 daughter eta"};
  Configurable<float> dauEtaMax{"v0detaMax", -0.8, "maximum V0 daughter eta"};

  Configurable<float> v0yMin{"v0yMin", -0.75, "minimum V0 y"};
  Configurable<float> v0yMax{"v0yMax", 0.75, "maximum V0 y"};
  Configurable<float> v0ptMin{"v0ptMin", 0.1, "minimum V0 pt"};
  Configurable<float> v0ptMax{"v0ptMax", 10.0, "maximum V0 pt"};
  Configurable<float> v0cospaMin{"v0cospaMin", 0.995, "minimum V0 CosPA"};
  Configurable<float> v0radiusMin{"v0radiusMin", 1.2, "V0 Radius"};
  Configurable<float> v0DCAdMax{"v0DCAdMax", 1.0, "maximum DCA V0 Daughters"};
  // Configurable<float> dcaprMin{"dcaprMin", .1, "DCA proton To PV"};
  // Configurable<float> dcapiMin{"dcapiMin", .1, "DCA pion To PV"};

  void init(InitContext const&)
  {
    auto h = histos.add<TH1>("hPreselectorStatistics", "hPreselectorStatistics", kTH1D, {{4, -0.5f, 3.5f}});
    h->GetXaxis()->SetBinLabel(1, "All");
    h->GetXaxis()->SetBinLabel(2, "Custom selection");
    h->GetXaxis()->SetBinLabel(3, "Jet selection");
    h->GetXaxis()->SetBinLabel(4, "BDT selection");
  }

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  template <class TTrack, typename TV0>
  bool JetSelection(TV0 const& v0)
  {
    auto negTrack = v0.template negTrack_as<TTrack>();
    auto posTrack = v0.template posTrack_as<TTrack>();
    if (negTrack.eta() < dauEtaMin || negTrack.eta() > dauEtaMax || posTrack.eta() < dauEtaMin || posTrack.eta() > dauEtaMax) {
      return false;
    }
    if (v0.v0radius() < v0radiusMin) {
      return false;
    }
    if (v0.v0cosPA() < v0cospaMin) {
      return false;
    }
    if (v0.dcaV0daughters() > dcav0dauMax) {
      return false;
    }
    if (v0.yK0Short() < v0yMin || v0.yK0Short() > v0yMax) {
      return false;
    }
    return true;
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processJets(aod::V0Data const v0, aod::Tracks const&)
  {
    selectionFlag += o2::v0data::Jet * JetSelection<aod::Tracks>(v0);
    v0presels(selectionFlag);
  }
  /// basic building options (one of them must be chosen)
  PROCESS_SWITCH(lambdakzeroPreselector, processJets, "Switch to preselect V0s for ch+V0 jets", true);
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<lambdakzeroPreselector>(cfgc)};
}
