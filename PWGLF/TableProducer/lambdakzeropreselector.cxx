// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
//
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//  Lambdakzero builder task
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//
//  This task loops over a set of V0 indices and
//  creates the corresponding analysis tables that contain
//  the typical information required for analysis.
//
//  PERFORMANCE WARNING: this task includes several track
//  propagation calls that are intrinsically heavy. Please
//  also be cautious when adjusting selections: these can
//  increase / decrease CPU consumption quite significantly.
//
//  IDEAL USAGE: if you are interested in taking V0s and
//  cascades and propagating TrackParCovs based on these,
//  please do not re-propagate the daughters. Instead,
//  the tables generated by this builder task can be used
//  to instantiate a TrackPar object (default operation)
//  or even a TrackParCov object (for which you will
//  need to enable the option of producing the V0Cov and
//  CascCov tables too).
//
//    Comments, questions, complaints, suggestions?
//    Please write to:
//    david.dobrigkeit.chinellato@cern.ch
//

#include <cmath>
#include <array>
#include <cstdlib>
#include <map>
#include <iterator>
#include <utility>

#include "Framework/runDataProcessing.h"
#include "Framework/RunningWorkflowInfo.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Framework/ASoAHelpers.h"
#include "DCAFitter/DCAFitterN.h"
#include "ReconstructionDataFormats/Track.h"
#include "Common/Core/RecoDecay.h"
#include "Common/Core/trackUtilities.h"
#include "PWGLF/DataModel/LFStrangenessTables.h"
#include "PWGLF/DataModel/LFParticleIdentification.h"
#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"
#include "DetectorsBase/Propagator.h"
#include "DetectorsBase/GeometryManager.h"
#include "DataFormatsParameters/GRPObject.h"
#include "DataFormatsParameters/GRPMagField.h"
#include "CCDB/BasicCCDBManager.h"
#include "DataFormatsCalibration/MeanVertexObject.h"
#include "TableHelper.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;
using std::array;

// simple checkers
#define bitset(var, nbit) ((var) |= (1 << (nbit)))
#define bitcheck(var, nbit) ((var) & (1 << (nbit)))

// use parameters + cov mat non-propagated, aux info + (extension propagated)
using FullTracksExt = soa::Join<aod::Tracks, aod::TracksExtra, aod::TracksCov>;
using FullTracksExtIU = soa::Join<aod::TracksIU, aod::TracksExtra, aod::TracksCovIU>;
using TracksWithExtra = soa::Join<aod::Tracks, aod::TracksExtra>;

// For dE/dx association in pre-selection
using TracksExtraWithPID = soa::Join<aod::TracksExtra, aod::pidTPCFullEl, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullHe>;

// For MC and dE/dx association
using TracksExtraWithPIDandLabels = soa::Join<aod::TracksExtra, aod::pidTPCFullEl, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullHe, aod::McTrackLabels>;

// Pre-selected V0s
using TaggedV0s = soa::Join<aod::V0s, aod::V0Tags>;

// For MC association in pre-selection
using LabeledTracksExtra = soa::Join<aod::TracksExtra, aod::McTrackLabels>;

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
struct lambdakzeroPreselector {
  Produces<aod::V0Presels> v0presels; // V0 preselections
  uint8_t selectionFlag;

  // for bookkeeping
  HistogramRegistry histos{"Histos", {}, OutputObjHandlingPolicy::AnalysisObject};

  Configurable<float> dauEtaMin{"v0detaMin", -0.8, "minimum V0 daughter eta"};
  Configurable<float> dauEtaMax{"v0detaMax", -0.8, "maximum V0 daughter eta"};

  Configurable<float> v0yMin{"v0yMin", -0.75, "minimum V0 y"};
  Configurable<float> v0yMax{"v0yMax", 0.75, "maximum V0 y"};
  Configurable<float> v0ptMin{"v0ptMin", 0.1, "minimum V0 pt"};
  Configurable<float> v0ptMax{"v0ptMax", 10.0, "maximum V0 pt"};
  Configurable<float> v0cospaMin{"v0cospaMin", 0.995, "minimum V0 CosPA"};
  Configurable<float> v0radiusMin{"v0radiusMin", 1.2, "V0 Radius"};
  Configurable<float> v0DCAdMax{"v0DCAdMax", 1.0, "maximum DCA V0 Daughters"};
  // Configurable<float> dcaprMin{"dcaprMin", .1, "DCA proton To PV"};
  // Configurable<float> dcapiMin{"dcapiMin", .1, "DCA pion To PV"};

  Configurable<bool> dIfMCgenerateK0Short{"dIfMCgenerateK0Short", true, "if MC, generate MC true K0Short (yes/no)"};
  Configurable<bool> dIfMCgenerateLambda{"dIfMCgenerateLambda", true, "if MC, generate MC true Lambda (yes/no)"};
  Configurable<bool> dIfMCgenerateAntiLambda{"dIfMCgenerateAntiLambda", true, "if MC, generate MC true AntiLambda (yes/no)"};
  Configurable<bool> dIfMCgenerateGamma{"dIfMCgenerateGamma", false, "if MC, generate MC true gamma (yes/no)"};
  Configurable<bool> dIfMCgenerateHypertriton{"dIfMCgenerateHypertriton", false, "if MC, generate MC true hypertritons (yes/no)"};
  Configurable<bool> dIfMCgenerateAntiHypertriton{"dIfMCgenerateAntiHypertriton", false, "if MC, generate MC true antihypertritons (yes/no)"};
  Configurable<int> dIfMCselectV0MotherPDG{"dIfMCselectV0MotherPDG", 0, "if MC, selects based on mother particle (zero for no selection)"};
  Configurable<bool> dIfMCselectPhysicalPrimary{"dIfMCselectPhysicalPrimary", true, "if MC, select MC physical primary (yes/no)"};
  Configurable<bool> ddEdxPreSelectK0Short{"ddEdxPreSelectK0Short", true, "pre-select dE/dx compatibility with K0Short (yes/no)"};
  Configurable<bool> ddEdxPreSelectLambda{"ddEdxPreSelectLambda", true, "pre-select dE/dx compatibility with Lambda (yes/no)"};
  Configurable<bool> ddEdxPreSelectAntiLambda{"ddEdxPreSelectAntiLambda", true, "pre-select dE/dx compatibility with AntiLambda (yes/no)"};
  Configurable<bool> ddEdxPreSelectGamma{"ddEdxPreSelectGamma", false, "pre-select dE/dx compatibility with gamma (yes/no)"};
  Configurable<bool> ddEdxPreSelectHypertriton{"ddEdxPreSelectHypertriton", false, "pre-select dE/dx compatibility with hypertritons (yes/no)"};
  Configurable<bool> ddEdxPreSelectAntiHypertriton{"ddEdxPreSelectAntiHypertriton", false, "pre-select dE/dx compatibility with antihypertritons (yes/no)"};
  // dEdx pre-selection compatibility
  Configurable<float> ddEdxPreSelectionWindow{"ddEdxPreSelectionWindow", 7, "Nsigma window for dE/dx preselection"};
  // tpc quality pre-selection
  Configurable<int> dTPCNCrossedRows{"dTPCNCrossedRows", 50, "Minimum TPC crossed rows"};
  // context-aware selections
  Configurable<bool> dPreselectOnlyBaryons{"dPreselectOnlyBaryons", false, "apply TPC dE/dx only to baryon daughters"};
  // for debugging and further tests
  Configurable<bool> forceITSOnlyMesons{"forceITSOnlyMesons", false, "force meson-like daughters to be ITS-only to pass Lambda/AntiLambda selections (yes/no)"};
  Configurable<int> minITSCluITSOnly{"minITSCluITSOnly", 0, "minimum number of ITS clusters to ask for if daughter track does not have TPC"};

  // for bit-packed maps
  std::vector<uint16_t> selectionMask;
  enum v0bit { bitInteresting = 0,
               bitTrackQuality,
               bitTrueGamma,
               bitTrueK0Short,
               bitTrueLambda,
               bitTrueAntiLambda,
               bitTrueHypertriton,
               bitTrueAntiHypertriton,
               bitdEdxGamma,
               bitdEdxK0Short,
               bitdEdxLambda,
               bitdEdxAntiLambda,
               bitdEdxHypertriton,
               bitdEdxAntiHypertriton,
               bitUsedInCascade,
               bitUsedInTrackedCascade };

  void init(InitContext const&)
  {
    auto h = histos.add<TH1>("hPreselectorStatistics", "hPreselectorStatistics", kTH1D, {{6, -0.5f, 5.5f}});
    h->GetXaxis()->SetBinLabel(1, "All");
    h->GetXaxis()->SetBinLabel(2, "Tracks OK");
    h->GetXaxis()->SetBinLabel(3, "MC label OK");
    h->GetXaxis()->SetBinLabel(4, "dEdx OK");
    h->GetXaxis()->SetBinLabel(5, "Used in Casc");
    h->GetXaxis()->SetBinLabel(6, "Used in Tra-Casc");
  }

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check track quality
  template <class TTrackTo, typename TV0Object>
  void checkTrackQuality(TV0Object const& lV0Candidate, uint16_t& maskElement, bool passdEdx = false)
  {
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // crossed rows conditionals
    bool posRowsOK = lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows;
    bool negRowsOK = lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows;

    // check track explicitly for absence of TPC
    bool posITSonly = !lPosTrack.hasTPC();
    bool negITSonly = !lNegTrack.hasTPC();
    bool longPosITSonly = posITSonly && lPosTrack.itsNCls() >= minITSCluITSOnly;
    bool longNegITSonly = negITSonly && lNegTrack.itsNCls() >= minITSCluITSOnly;

    // No baryons in decay
    if (((bitcheck(maskElement, bitdEdxGamma) || bitcheck(maskElement, bitdEdxK0Short)) || passdEdx) && (posRowsOK && negRowsOK) && (!forceITSOnlyMesons || (posITSonly && negITSonly)))
      bitset(maskElement, bitTrackQuality);
    // With baryons in decay
    if ((bitcheck(maskElement, bitdEdxLambda) || passdEdx) &&               // logical AND with dEdx
        (posRowsOK && (negRowsOK || dPreselectOnlyBaryons)) &&              // rows requirement
        ((posRowsOK || longPosITSonly) && (negRowsOK || longNegITSonly)) && // if ITS-only, check for min length
        (!forceITSOnlyMesons || negITSonly))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxAntiLambda) || passdEdx) &&           // logical AND with dEdx
        (negRowsOK && (posRowsOK || dPreselectOnlyBaryons)) &&              // rows requirement
        ((posRowsOK || longPosITSonly) && (negRowsOK || longNegITSonly)) && // if ITS-only, check for min length
        (!forceITSOnlyMesons || posITSonly))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxHypertriton) || passdEdx) &&          // logical AND with dEdx
        (posRowsOK && (negRowsOK || dPreselectOnlyBaryons)) &&              // rows requirement
        ((posRowsOK || longPosITSonly) && (negRowsOK || longNegITSonly)) && // if ITS-only, check for min length
        (!forceITSOnlyMesons || negITSonly))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxAntiHypertriton) || passdEdx) &&      // logical AND with dEdx
        (negRowsOK && (posRowsOK || dPreselectOnlyBaryons)) &&              // rows requirement
        ((posRowsOK || longPosITSonly) && (negRowsOK || longNegITSonly)) && // if ITS-only, check for min length
        (!forceITSOnlyMesons || posITSonly))
      bitset(maskElement, bitTrackQuality);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check PDG association
  template <class TTrackTo, typename TV0Object>
  void checkPDG(TV0Object const& lV0Candidate, uint16_t& maskElement)
  {
    int lPDG = -1;
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // Association check
    // There might be smarter ways of doing this in the future
    if (lNegTrack.has_mcParticle() && lPosTrack.has_mcParticle()) {
      auto lMCNegTrack = lNegTrack.template mcParticle_as<aod::McParticles>();
      auto lMCPosTrack = lPosTrack.template mcParticle_as<aod::McParticles>();
      if (lMCNegTrack.has_mothers() && lMCPosTrack.has_mothers()) {
        for (auto& lNegMother : lMCNegTrack.template mothers_as<aod::McParticles>()) {
          for (auto& lPosMother : lMCPosTrack.template mothers_as<aod::McParticles>()) {
            if (lNegMother.globalIndex() == lPosMother.globalIndex() && (!dIfMCselectPhysicalPrimary || lNegMother.isPhysicalPrimary())) {
              lPDG = lNegMother.pdgCode();

              // additionally check PDG of the mother particle if requested
              if (dIfMCselectV0MotherPDG != 0) {
                lPDG = 0; // this is not the species you're looking for
                if (lNegMother.has_mothers()) {
                  for (auto& lNegGrandMother : lNegMother.template mothers_as<aod::McParticles>()) {
                    if (lNegGrandMother.pdgCode() == dIfMCselectV0MotherPDG)
                      lPDG = lNegMother.pdgCode();
                  }
                }
              }
              // end extra PDG of mother check
            }
          }
        }
      }
    } // end association check
    if (lPDG == 310)
      bitset(maskElement, bitTrueK0Short);
    if (lPDG == 3122)
      bitset(maskElement, bitTrueLambda);
    if (lPDG == -3122)
      bitset(maskElement, bitTrueAntiLambda);
    if (lPDG == 22)
      bitset(maskElement, bitTrueGamma);
    if (lPDG == 1010010030)
      bitset(maskElement, bitTrueHypertriton);
    if (lPDG == -1010010030)
      bitset(maskElement, bitTrueAntiHypertriton);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  template <class TTrackTo, typename TV0Object>
  void checkdEdx(TV0Object const& lV0Candidate, uint16_t& maskElement)
  {
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // dEdx check with LF PID
    if (TMath::Abs(lNegTrack.tpcNSigmaEl()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaEl()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxGamma);
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxK0Short);
    if ((TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons) &&
        TMath::Abs(lPosTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxLambda);
    if (TMath::Abs(lNegTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        (TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons))
      bitset(maskElement, bitdEdxAntiLambda);
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        (TMath::Abs(lPosTrack.tpcNSigmaHe()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons))
      bitset(maskElement, bitdEdxHypertriton);
    if ((TMath::Abs(lNegTrack.tpcNSigmaHe()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons) &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxAntiHypertriton);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// Initialization of mask vectors if uninitialized
  void initializeMasks(int size)
  {
    if (selectionMask.size() < 1) {
      // reserve // FIXME check speed / optimise
      selectionMask.resize(size, 0);
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// Clear mask vectors
  void resetMasks()
  {
    selectionMask.clear();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// checks and publishes tags if last
  void checkAndFinalize()
  {
    // parse + publish tag table now
    for (int ii = 0; ii < selectionMask.size(); ii++) {
      histos.fill(HIST("hPreselectorStatistics"), 0.0f); // all V0s
      bool validV0 = bitcheck(selectionMask[ii], bitTrackQuality);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 1.0f); // pass track quality
      }
      if (doprocessBuildMCAssociated || doprocessBuildValiddEdxMCAssociated)
        validV0 = validV0 && ((bitcheck(selectionMask[ii], bitTrueK0Short) && dIfMCgenerateK0Short) ||
                              (bitcheck(selectionMask[ii], bitTrueLambda) && dIfMCgenerateLambda) ||
                              (bitcheck(selectionMask[ii], bitTrueAntiLambda) && dIfMCgenerateAntiLambda) ||
                              (bitcheck(selectionMask[ii], bitTrueGamma) && dIfMCgenerateGamma) ||
                              (bitcheck(selectionMask[ii], bitTrueHypertriton) && dIfMCgenerateHypertriton) ||
                              (bitcheck(selectionMask[ii], bitTrueAntiHypertriton) && dIfMCgenerateAntiHypertriton));
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 2.0f); // pass MC
      }
      if (doprocessBuildValiddEdx || doprocessBuildValiddEdxMCAssociated)
        validV0 = validV0 && ((bitcheck(selectionMask[ii], bitdEdxK0Short) && ddEdxPreSelectK0Short) ||
                              (bitcheck(selectionMask[ii], bitdEdxLambda) && ddEdxPreSelectLambda) ||
                              (bitcheck(selectionMask[ii], bitdEdxAntiLambda) && ddEdxPreSelectAntiLambda) ||
                              (bitcheck(selectionMask[ii], bitdEdxGamma) && ddEdxPreSelectGamma) ||
                              (bitcheck(selectionMask[ii], bitdEdxHypertriton) && ddEdxPreSelectHypertriton) ||
                              (bitcheck(selectionMask[ii], bitdEdxAntiHypertriton) && ddEdxPreSelectAntiHypertriton));
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 3.0f); // pass dEdx
      }
      if (doprocessSkipV0sNotUsedInCascades)
        validV0 = validV0 && bitcheck(selectionMask[ii], bitUsedInCascade);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 4.0f); // pass used in casc
      }
      if (doprocessSkipV0sNotUsedInTrackedCascades)
        validV0 = validV0 && bitcheck(selectionMask[ii], bitUsedInTrackedCascade);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 5.0f); // pass used in tracasc
      }
      v0tags(validV0,
             bitcheck(selectionMask[ii], bitTrueGamma), bitcheck(selectionMask[ii], bitTrueK0Short), bitcheck(selectionMask[ii], bitTrueLambda),
             bitcheck(selectionMask[ii], bitTrueAntiLambda), bitcheck(selectionMask[ii], bitTrueHypertriton), bitcheck(selectionMask[ii], bitTrueAntiHypertriton),
             bitcheck(selectionMask[ii], bitdEdxGamma), bitcheck(selectionMask[ii], bitdEdxK0Short), bitcheck(selectionMask[ii], bitdEdxLambda),
             bitcheck(selectionMask[ii], bitdEdxAntiLambda), bitcheck(selectionMask[ii], bitdEdxHypertriton), bitcheck(selectionMask[ii], bitdEdxAntiHypertriton),
             bitcheck(selectionMask[ii], bitUsedInCascade), bitcheck(selectionMask[ii], bitUsedInTrackedCascade));
    }
    resetMasks();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  template <class TTrack, typename TV0>
  bool JetSelection(TV0 const& v0)
  {
    auto negTrack = v0.template negTrack_as<TTrack>();
    auto posTrack = v0.template posTrack_as<TTrack>();
    if (negTrack.eta() < dauEtaMin || negTrack.eta() > dauEtaMax || posTrack.eta() < dauEtaMin || posTrack.eta() > dauEtaMax) {
      return false;
    }
    if (v0.v0radius() < v0radiusMin) {
      return false;
    }
    if (v0.v0cosPA() < v0cospaMin) {
      return false;
    }
    if (v0.dcaV0daughters() > dcav0dauMax) {
      return false;
    }
    if (v0.yK0Short() < v0yMin || v0.yK0Short() > v0yMax) {
      return false;
    }
    return true;
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processJets(aod::V0Data const v0, aod::Tracks const&)
  {
    selectionFlag += o2::v0data::Jet * JetSelection<aod::Tracks>(v0);
    v0presels(selectionFlag);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function ensures that all V0s are built. It will simply tag everything as true.
  void processBuildAll(aod::V0s const& v0table, aod::TracksExtra const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkTrackQuality<aod::TracksExtra>(v0, selectionMask[v0.globalIndex()], true);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildMCAssociated(aod::Collisions const& collisions, aod::V0s const& v0table, LabeledTracksExtra const&, aod::McParticles const& particlesMC)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkPDG<LabeledTracksExtra>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<LabeledTracksExtra>(v0, selectionMask[v0.globalIndex()], true);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdx(aod::Collisions const& collisions, aod::V0s const& v0table, TracksExtraWithPID const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkdEdx<TracksExtraWithPID>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<TracksExtraWithPID>(v0, selectionMask[v0.globalIndex()]);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdxMCAssociated(aod::Collisions const& collisions, aod::V0s const& v0table, TracksExtraWithPIDandLabels const&, aod::McParticles const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkPDG<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
      checkdEdx<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function checks for the use of V0s in cascades
  /// They are then marked appropriately; the user could then operate
  /// the lambdakzerobuilder to construct only those V0s.
  void processSkipV0sNotUsedInCascades(aod::Cascades const& casctable)
  {
    for (auto const& casc : casctable) {
      bitset(selectionMask[casc.v0Id()], bitUsedInCascade); // tag V0s needed by cascades
    }
    checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function checks for the use of V0s in strangeness tracked cascades
  /// They are then marked appropriately; the user could then operate
  /// the lambdakzerobuilder to construct only those V0s.
  void processSkipV0sNotUsedInTrackedCascades(aod::TrackedCascades const& tracasctable, aod::Cascades const& casctable)
  {
    for (auto const& tracasc : tracasctable) {
      auto casc = tracasc.cascade();
      bitset(selectionMask[casc.v0Id()], bitUsedInTrackedCascade); // tag V0s needed by tracked cascades
    }
    checkAndFinalize();
  }
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
  /// basic building options (one of them must be chosen)
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildAll, "Switch to build all V0s", true);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildMCAssociated, "Switch to build MC-associated V0s", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildValiddEdx, "Switch to build V0s with dE/dx preselection", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildValiddEdxMCAssociated, "Switch to build MC-associated V0s with dE/dx preselection", false);
  /// skippers options (choose one in addition to a processBuild if you like)
  PROCESS_SWITCH(lambdakzeroPreselector, processSkipV0sNotUsedInCascades, "skip all V0s not used in cascades", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processSkipV0sNotUsedInTrackedCascades, "skip all V0s not used in tracked cascades", false);
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<lambdakzeroPreselector>(cfgc)};
}
